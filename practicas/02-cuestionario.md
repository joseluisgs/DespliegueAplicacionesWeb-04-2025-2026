# Cuestionario Avanzado sobre Despliegue de Aplicaciones Web


1.  **Optimización de Logging y Recursos:** Compare la gestión de recursos y la eficacia de la **rotación de logs básica** con el *json-file driver* de Docker (limitando el tamaño y la cantidad de archivos) frente a la implementación de un **Log Shipper** centralizado (como Fluentd o Logstash). Investigue cómo la indexación en Elasticsearch permite ir más allá de la mera lectura de logs, realizando análisis estructurados en tiempo real.

2.  **Seguridad y Centralización SSL:** Investigue las ventajas de la **terminación SSL centralizada** en el proxy inverso (Nginx) en términos de rendimiento y gestión de certificados, como se menciona en las conclusiones del laboratorio de proxy. Compare la complejidad de generar certificados autofirmados con OpenSSL versus el uso de soluciones de producción como **Let's Encrypt (Certbot)** en un entorno Dockerizado para la gestión automática de certificados.

3.  **Balanceo de Carga y Persistencia de Sesión:** El algoritmo de balanceo `round-robin` es el predeterminado en Nginx, pero `ip_hash` garantiza que un cliente siempre acceda al mismo *backend*. Diseñe y pruebe un escenario de despliegue con Docker Compose y Nginx donde la falta de **persistencia de sesión** (usando `round-robin`) cause fallos críticos en una aplicación con estado, demostrando la necesidad de implementar el algoritmo `ip_hash`.

4.  **Modularidad y Activación de Servidores en Contenedores:** Analice las diferencias en la activación de configuraciones y módulos entre Apache (usando `a2enmod`/`a2ensite`) y Nginx. Proponga una solución de *entrypoint* para un contenedor Apache que permita activar dinámicamente un número variable de *Virtual Hosts* montados por volumen al inicio, garantizando que el *script* use el comando de seguridad `apache2ctl configtest` antes de cualquier recarga (`service apache2 reload`).

5.  **Optimización de Imágenes Java:** Investigue y cuantifique la diferencia de tamaño y las ventajas de seguridad al utilizar el enfoque de **múltiples etapas (*Multi-stage build*)** para la construcción de una imagen Docker de una aplicación Java (JVM), en comparación con un *build* de una sola etapa que incluya tanto el entorno de compilación (Maven/Gradle) como el entorno de ejecución (OpenJDK).

6.  **Desarrollo Serverless con Netlify:** Netlify permite desplegar sitios estáticos y ofrece **Netlify Functions** para lógica de backend. Investigue cómo se pueden utilizar las *Functions* junto con **Netlify Identity** y los formularios nativos para desarrollar una aplicación *full-stack* moderna (JAMstack) que evite completamente la necesidad de mantener un servidor backend tradicional (ej. Apache o Nginx) y una base de datos expuesta.

7.  **CI/CD Avanzado y Prevención de Bucles:** Profundice en el mecanismo de seguridad de GitHub Actions que, por defecto, previene que los *commits* realizados por `GITHUB_TOKEN` re-disparen el mismo *workflow*. Desarrolle un *workflow* avanzado que, además de construir y publicar la imagen Docker en GHCR, incluya un paso de **escaneo de seguridad** de la imagen y que, al actualizar el `index.html`, utilice la acción `stefanzweifel/git-auto-commit-action` para gestionar el *commit* de manera segura.

8.  **Arquitectura de Redes y Service Discovery:** En una arquitectura con Proxy Inverso y múltiples *backends* escalados con Docker Compose (`--scale`), explique cómo el **Service Discovery** de Docker facilita que el proxy Nginx resuelva automáticamente las direcciones IP de los contenedores *backend*. Investigue cómo configurar una red interna en Docker Compose para garantizar que los *backends* solo sean accesibles a través del proxy por razones de seguridad.

9.  **Pruebas de Resiliencia en Proxy Inverso:** Investigue y proponga la implementación de **healthchecks** para los servidores *backend* dentro de la directiva `upstream` de Nginx, como se sugiere en los ejercicios propuestos. Diseñe un experimento para verificar que Nginx, al detectar un *backend* fallido, automáticamente deja de enviarle tráfico hasta que el servicio se recupera, garantizando así la alta disponibilidad.

10. **Documentación Operacional (Runbook):** Diseñe una plantilla exhaustiva de un archivo `README.md` (o *runbook* operacional) que sirva como manual para un administrador, cubriendo la estructura completa de un despliegue Docker Compose con proxy inverso y logs centralizados. La plantilla debe incluir secciones obligatorias para **Configuración de Hosts Local**, Comandos de Mantenimiento (`apache2ctl configtest`, `nginx -t`, `reload`), Pasos para la Limpieza Total (`docker-compose down -v`), y gestión de *Secrets*.